#pragma once
#include <string>
#include <vector>
#include "Thing.class"
#include "Cell.class"



class World {
	//int *ptr = nullptr; // объявляем указатель на переменную

    /*void setPtr(int* ptr) { // метод для установки указателя
        this->ptr = ptr;
    }*/

public:
	std::map<unsigned long, Thing> obs; // id, obj
	std::string name;
	std::vector<std::vector<std::vector<Cell>>> grid; // этаж | y | x

	/*World(){
		cur_world_ptr = this;
		name = "new_name";
	}*/

	void gen(int nx, int ny, int layers){
		// заполнение сетки мира клетками
		for(int il=0; il<layers; il++){
			std::vector<std::vector<Cell>> layer;
			for(int iy=0; iy<ny; iy++){
				std::vector<Cell> line;
				Cell new_c1 = Cell(/*this*/);
				line.push_back(new_c1);
				for(int ix=0; ix<nx-2; ix++){
					Cell new_c = Cell(/*this*/);
					line.push_back(new_c);
				}
				line.push_back(new_c1);

				layer.push_back(line);
			}
			grid.push_back(layer);
		}

		// заполнение клеток объектами
		for(int il=0; il<layers; il++){
			for(int iy=0; iy<ny; iy++){
				addObj(Vector3i(il,iy,0), Thing("v_wall"));
				for(int ix=1; ix<nx-1; ix++){
					addObj(Vector3i(il,iy,ix), Thing("floor"));
				}
				//grid[il][iy][grid[il][iy].size()-1].addObj(Thing("v_wall"));
				addObj(Vector3i(il,iy,grid[il][iy].size()-1), Thing("v_wall"));
			}
		}
		// Герой:
		addObj(Vector3i(0,2,1), Thing("player"));

	}

	std::vector<std::vector<std::string>> get_str(int layer){
        std::vector<std::vector<std::string>> rez;

		for(int iy=0; iy<grid[layer].size(); iy++){
			std::vector<std::string> line;
			for(int ix=0; ix<grid[layer][iy].size(); ix++){
				std::vector<Thing> tmp;
				for(auto i : grid[layer][iy][ix].obs_id){ tmp.push_back(obs[i]); }
				if(tmp.size()==0){
					line.push_back(" ");
				}else{
					std::sort(tmp.begin(), tmp.end(), compareByPrimary);
					line.push_back(tmp[0].symbol);
				}

			}
			rez.push_back(line);
		}
		return rez;
    }

	void tick(World& world){
		for(auto& item : obs){
			item.second.tick(world);
		}
	}

	// ====== действия с объектами ======
	void addObj(Vector3i cellpos, Thing obj){ // добавить объект в клетку
		//(*world_ptr).obs[obj.id] = obj;
		obs[obj.id] = obj;
		grid[cellpos.x][cellpos.y][cellpos.z].obs_id.push_back(obj.id);
	}

	void moveObj(unsigned long id, std::string route){
		int ry, rx;
		if(route=="up"){ ry=-1; rx=0; }
		if(route=="down"){ ry=1; rx=0; }
		if(route=="left"){ ry=0; rx=-1; }
		if(route=="right"){ ry=0; rx=1; }
		for(int il=0; il<grid.size(); il++){
			for(int iy=0; iy<grid[il].size(); iy++){
				for(int ix=0; ix<grid[il][iy].size(); ix++){
					for(unsigned long i : grid[il][iy][ix].obs_id){
						print(std::to_string(i));
						//print(std::to_string(id_buffer["player_id"]));
						if(i==id){
							print("+===+");
							print(std::to_string(i));
							auto it = std::remove(grid[il][iy][ix].obs_id.begin(), grid[il][iy][ix].obs_id.end(), i);
							grid[il][iy][ix].obs_id.erase(it, grid[il][iy][ix].obs_id.end());
							grid[il][iy+ry][ix+rx].obs_id.push_back(i);
						}
					}
				}
			}
		}
		print(std::to_string(tid));
	}
};

void Player::tick(World& world){
	unsigned long cid = thing_ptr->id;
	switch(cross_screen_buffer["PlayerCom"]) {
		case 1:
			world.moveObj(cid, "up");
		break;
		case 2:
			world.moveObj(cid, "down");
			world.grid[0][5][5].obs_id.push_back(400);
		break;
		case 3:
			world.moveObj(cid, "left");
		break;
		case 4:
			world.moveObj(cid, "right");
		break;
	}
}
